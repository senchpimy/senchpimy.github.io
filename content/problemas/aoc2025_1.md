---
#date: "1 December 2025"
title: "Advent of Code 2025: 1"
katex: true
---

Este problema consiste en encontrar la combinacion
a una llave, la combinacion se nods da contando las
veces que se llego a 0 despues de aplicar ciertas 
rotaciones a una perilla
 
### Solucion

Hay dos tipos de instrucciones, la izquierda resta al total
y la derecha suma al total, empezamos desde el 50 y se puede girar 
un total de 100 diferentes grados, es un circulo el que estamos girando
por lo que si llegamos al 100 cualquier numero empezara desde
el 0 y (114 -> 14) y si de 0 retrocedemos la poscicion sera
igual a 100 - n

```py
comienza = 50
total = 0
radio = 100
with open("./input.txt", "r") as f:
    lines = f.readlines()
    for line in lines:
        line = line[:-1]
        num, direccion = int(line[1::]), line[0]
        if direccion == "R":
            comienza += num
        else:
            comienza -= num

        comienza %= radio

        if comienza == 0:
            total += 1

print(total)
```

En esta solucion leemos el archivo y dependiendo el valor lo sumamos
o restamos, y para tomar en cuenta sobre los retornos se asigna como
valor de la poscicion actual el valor del modulo de la division de la
poscicion actual con entre el radio, ya que prescisamente tiene este comportamiento

$$ 105 \bmod 100 = 5 $$
$$ -5\bmod100 = 95 $$

Y el mismo programa en go
```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	file, err := os.Open("input.txt")
	if err != nil {
		fmt.Println("Error al abrir input.txt:", err)
		return
	}
	defer file.Close()

	position := 50
	zeroCount := 0
	radio := 100

	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		direction := line[0]

		steps, err := strconv.Atoi(line[1:])
		if err != nil {
			continue
		}

		if direction == 'R' {
			position = (position + steps) % radio
		} else if direction == 'L' {
			position = (position - steps) % radio

			if position < 0 {
				position += radio
			}
		}

		if position == 0 {
			zeroCount++
		}
	}

	if err := scanner.Err(); err != nil {
		fmt.Println("Error leyendo el archivo:", err)
	}

	fmt.Printf("Reultado: %d", zeroCount)
}
```

Seria la siguiente formula:

Definimos el cambio $$\Delta_k$$ basado en la dirección:

$$\Delta_k = \begin{cases}    v_k & \text{si } d_k = R \quad (\text{Derecha}) \\\\   -v_k & \text{si } d_k = L \quad (\text{Izquierda}) \end{cases}$$

La posición en el paso *k* se actualiza módulo 100:

$$\[ P_k = (P_{k-1} + \Delta_k) \pmod{100}\]$$

La contraseña **C** es el número de veces que la posición final es 0.:
$$\[C = \sum_{k=1}^{N} \mathbb{I}(P_k = 0)\]$$
$$\textit{Donde $\mathbb{I}(x)$ vale 1 si la condición es verdadera y 0 si es falsa.}$$
