---
date: "2025-12-07"
title: "Advent of Code 2025: 7"
katex: true
---

El problema consiste en que hay un rayo
y este tiene que pasar por diferentes
lineas, pero existe la posibilidad que este se divida
en dos rayos, lo que define si esto sucede es si
exite un divisor en la linea que se esta revisando

```txt
.......S.......
.......|.......
......|^|......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............
```

Y se deben de contar cuantas veces se dividio el rayo

### Solucion

Mi primera solución consistio en tener solo
una linea con los rayos actuales y aplicar la linea siguiente
como una "mascara" sobre la linea actual

```py
global total

total = 0


def update(actual: list[bool], val: str):
    for index, el in enumerate(actual):
        if el:
            if val[index] == "^":
                global total
                total += 1
                actual[index-1] = True
                actual[index+1] = True
                actual[index] = False
                pass
    return actual


# with open("./input_test.txt", "r") as f:
with open("./input.txt", "r") as f:
    lines = f.readlines()
    le = len(lines[0])-1
    first = lines[0]
    index = first.find("S")
    bars = [False for _ in range(le)]
    bars[index] = True
    for line in lines:
        line = line.strip()
        bars = update(bars, line)
print(f"Resultado {total}")

print("".join([("|" if x else ".") for x in bars]))
```

Pero existe una mejor solución, en la cual solo
tenemos que almacenar el indice en el que hay un rayo
y aplicamos la misma logica de solo buscar si existe
un divisor bajo los rayos actuales

```py
global total

total = 0


def update(actual: set, val: str):
    nuevo = set()
    for el in actual:
        print(val[el])
        if val[el] == "^":
            global total
            total += 1
            print(el)
            nuevo.add(el+1)
            nuevo.add(el-1)
        else:
            nuevo.add(el)
    return nuevo

    # with open("./input_test.txt", "r") as f:
with open("./input.txt", "r") as f:
    lines = f.readlines()
    le = len(lines[0])-1
    first = lines[0]
    index = first.find("S")
    bars = set()
    bars.add(index)
    print(bars)
    for line in lines:
        line = line.strip()
        bars = update(bars, line)
print(f"Resultado {total}")
```
