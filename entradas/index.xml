<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Entradas on Senchpimy</title><link>https://senchpimy.github.io/entradas/</link><description>Recent content in Entradas on Senchpimy</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 15 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://senchpimy.github.io/entradas/index.xml" rel="self" type="application/rss+xml"/><item><title>Programando un Pic16F887 desde Arch Linux en 2025</title><link>https://senchpimy.github.io/entradas/usarpic/</link><pubDate>Mon, 15 Sep 2025 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/usarpic/</guid><description>Introducción En este artículo, te guiaré a través del proceso de programación de un microcontrolador PIC16F887 utilizando Arch Linux. A pesar de que existen muchas herramientas y métodos para programar microcontroladores, aquí nos enfocaremos en una solución sencilla y efectiva utilizando herramientas de línea de comandos.
Requisitos previos Antes de comenzar, asegúrate de tener lo siguiente:
Un microcontrolador PIC16F887. Un programador compatible con PIC, en mi caso estoy usando el PICkit 2.</description></item><item><title>Cross Validation</title><link>https://senchpimy.github.io/entradas/cross-validation/</link><pubDate>Mon, 17 Mar 2025 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/cross-validation/</guid><description>Cross Validation Es una tecnica que sirve para validar como un analisis estadistico generaliza una serie de datos independientes, se usa cuando la meta es la prediccion y uno quiere estimar que tan preciso es el modelo en las predicciones.
En problema de prediccion se tiene una serie de datos en la cual el modelo se entrenara (datos de entrenamiento) y otros datos desconocidos para el modelo, contra los cuales es el modelo probado, la meta de la cross validacion es probar la habilidad de el modelo de predecir más nuevos datos usando valores que no se usaron para entrenarlo, asi se pueden encotrar problemas como overfitting o sesgo de selección</description></item><item><title>Maquina De Estados Determinista Finita</title><link>https://senchpimy.github.io/entradas/maquinafinitarust/</link><pubDate>Tue, 10 Sep 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/maquinafinitarust/</guid><description>Una Mquina de estados finita consiste en un sistema el cual posee una serie de estados determinados y finitos, los cuales segun la entrada que entre al sistema, este tomara una desciocion y cambiara de estado. EL cambio de estado se llama transcicion de estado.
Ejemplo Para este ejemplo maquina tendra 3 estados, cerrado, abierto y bloqueado,
%%{ init: { 'theme': 'base', 'themeVariables': { 'primaryColor': '#BB2528', 'primaryTextColor': '#fff', 'primaryBorderColor': '#7C0000', 'lineColor': '#F8B229', 'secondaryColor': '#006100', 'tertiaryColor': '#fff' } } }%%stateDiagram-v2 cerrado: Estado Cerrado abierto: Estado Abierto bloqueado: Estado Bloqueado cerrado --> abierto: Contraseña Correcta cerrado --> bloqueado: 3 Contraseñas Incorrectas En rust podriamos represnetar cada Estado como un Enum</description></item><item><title>RAG</title><link>https://senchpimy.github.io/entradas/rag/</link><pubDate>Tue, 10 Sep 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/rag/</guid><description>Retrieval Aumented Generation RAG consiste en proporcionar a un modelo de lenguaje informacion de tal manera en que la salida de estos modelos no solo sea la contenida en el mismo modelo, si no que sea recuperada de la informacion que le fue proporcionada. Este metodo es muy interesante pues aumenta las capacidades de un modelo ya existente sin la necesidad de volver a entrena o de fintunear.
Funcionamiento Este metodo se puede dividir en tres partes:</description></item><item><title>Forma Backus-Naur</title><link>https://senchpimy.github.io/entradas/backusnaurform/</link><pubDate>Sun, 08 Sep 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/backusnaurform/</guid><description>Conceptos Sintaxis: La sintaxis son las reglas que definen una combinacion de simbolos que forman parte de expresiones o declaraciones correctamente estructuradas en ese lenguaje Lenguaje Formal: En la logica y matematica un lenguaje formal es consiste de palabras cuyas letras son tomadas de un alfabeto y se conforman de acuerdo a un set especifico de reglas llamadas gramatica formal Metasintaxis: Es la sintaxis usada para definir una sintaxis Gramatica libre de contexto: En lenguajes formales una gramatica libre de contexto es una gramatica cuyas reglas de produccion pueden ser aplicadas a simbolos no no-terminales sin importar su contexto.</description></item><item><title>Random Forest</title><link>https://senchpimy.github.io/entradas/randomforest/</link><pubDate>Sun, 08 Sep 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/randomforest/</guid><description>Conceptos Metodo de Ensamble: Es un metodo que combina multiples modelos de aprendizaje para mejorar la generalizacion y la robustez sobre un unico modelo. El metodo de ensamble entrena dos o mas modelos de aprendizaje en una tarea especifica de regresion o clasificacion.
Arbol de Decision: Es un modelo de aprendizaje supervisado que se utiliza para la toma de decisiones. Es un arbol que se compone de nodos y ramas. los nodos representan las caracteristicas de un conjunto de datos y las ramas representan las reglas (conjunciones) de decision que se toman para llegar</description></item><item><title>Calculo Lambda</title><link>https://senchpimy.github.io/entradas/calculolambda/</link><pubDate>Tue, 23 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/calculolambda/</guid><description>Conceptos Formalismo Matematico: En las matematicas la formalizacion es una teoria que sostiene que las proposiciones de la matematica
Sistema formal: Es una estructura abstracta y formalizacion de un sistema de axiomas usado para inferir teoremas de axiomas dado una reglas de inferencia
Reglas de inferencia: Una regla de Inferencia es una forma logica que consiste en una funcion que toma una premisa, analiza su syntaxis y regresa una conclusion</description></item><item><title>Metodo Montecarlo</title><link>https://senchpimy.github.io/entradas/metodomontecarlo/</link><pubDate>Thu, 18 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/metodomontecarlo/</guid><description>Metodo Montecarlo Es un algoritmo no determinista (con una misma entrada puede tener salidas diferentes) usado para aproximar expresiones matematicas complejas.
Este metodo puede ser aplicado a cualquier problema estocastico (depende de procesos aleatorios) o determinista (sistema en el que el azar no esta involucrado en el desarrollo de los futuros estados del sistema). A diferencia de los metodos numericos que se basan en evaluaciones en N puntos en un espacio de M dimenciones para producir una solucion aproximada, el metodo de montecarlo tiene un error absoluto que decrece como: $$ \frac{1}{\sqrt{N}}$$</description></item><item><title>Entrenando una Red Neuronal</title><link>https://senchpimy.github.io/entradas/simpleredneuronal/</link><pubDate>Thu, 11 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/simpleredneuronal/</guid><description>Introducción Esta entrada habla sobre el algoritmo NEAT que no solo hace que la red aprenda los pesos si no tambien su arquitectura
NeuroEvolution of Augmenting Topologies (NEAT) En una red NEAT se usa dags (directed acyclic graphs) para representar las redes neuronales, un dags en un grafo en el cual no hay ciclos, este tipos de redes no estan totalmente conectadas, por lo que se usa ordenamiento topologico para determinar el orden en el que se llevaran a cabo las operaciones, pues se ordenan los nodos de acuerdo a su antecesor de tal manera que el descendiente siempre valla despues de el precedente</description></item><item><title>Diffusion VS Autoregresion</title><link>https://senchpimy.github.io/entradas/difussionvsautoregresion/</link><pubDate>Fri, 05 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/difussionvsautoregresion/</guid><description>Generar Imagenes El problema de generar imagenes puede ser reducido a un problema de prediccion. Primero se tiene que encontrar una manera de introducir los datos al modelo, pues si solo se introducen imagenes con una etiqueta el modelo generara un promedio de todas las imagenes con la misma etiqueta, es decir una imagen la cual cada pixel de esta imagen es el promedio de los demas pixeles que se encuentran en esa misma posscicion en las otras imagenes.</description></item><item><title>Mamba</title><link>https://senchpimy.github.io/entradas/mamba/</link><pubDate>Thu, 04 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/mamba/</guid><description>Mamba Mamba es una nueva arquitectura de redes neuronales que es mejor que los transformers en el modelado de lenguaje, tambien es mas eficiente computacionalmente, pues para procesar una sequencia de n palabras tiene una complejidad nlogn mientras que los transformers tienen n^2
Modelos State-space Estos son una alternativa a modelos sequenciales tales como HiPPO, Discretization, Structured State-Space Models que combina Redes neuronales Recurrentes
Redes Neuronales Recurrentes Una red convolucional aplica una red neuronal a una serie de vectores al mismo tiempo, en comparacion a una tradicional en donde se analiza toda la informacion como un solo vector, este cambio en arquitectura logra que la informacion que se transmite entre capas pueda tener un cierto &amp;ldquo;contexto&amp;rdquo; con la informacion a su alrededor, que funciono muy bien para el analisis de imagenes y aplicando este mismo conecpto al texto, puede añadir conexto a las palabras segun las otras palabras que esten a su alrededor.</description></item><item><title>Rompiendo RSA</title><link>https://senchpimy.github.io/entradas/rompiendorsa/</link><pubDate>Thu, 04 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/rompiendorsa/</guid><description>RSA RSA es un algoritmo de encriptacion que consiste en la factorizacion de dos numeros primos, actualmentes estos numeros son de el orden de los 10^300.
Rompiendo RSA Siendo valores publicos e y n, y siendo un valor privado d, n = p*q. El proceso para romper RSA consiste en encontrar algunos de los dos valor p o q.
Para RSA se requiere tambien calcular la funcion de euler de n que se define como (p-1)*(q-1)</description></item><item><title>timetravel</title><link>https://senchpimy.github.io/entradas/timetravel/</link><pubDate>Wed, 26 Oct 2022 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/entradas/timetravel/</guid><description>La filosofia de el Viaje en el Tiempo Estas son las paginas del el libro de ficcion &amp;ldquo;La Filosofia de el el Viaje En El Tiempo&amp;rdquo; por Roberta Sparrow.
Prefacio Me gustaria agradecer a las hermanas de la capilla de San John en Alexandria, Virginia por su apoyo en mi descicion, Por la gracia de Dios, ellas son:
Hermana Eleanor Lewis Hermana Francesca Godiani Hermana Helen Davis Hermana CAtherine Arnold Hermana Mary Lee Pond Hermana Virginia Wessex El proposito de este pequeño libro se para ser usado como una gia simple y directaen algun momento de gran peligro.</description></item></channel></rss>