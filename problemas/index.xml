<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Problemas on Senchpimy</title><link>https://senchpimy.github.io/problemas/</link><description>Recent content in Problemas on Senchpimy</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 19 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://senchpimy.github.io/problemas/index.xml" rel="self" type="application/rss+xml"/><item><title>Ordenar Colores</title><link>https://senchpimy.github.io/problemas/ordenarcolores/</link><pubDate>Fri, 19 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/ordenarcolores/</guid><description>Ordenar colores Este problema consisten en dado un array con los numeros: 0, 1, 2. Ordenar el array sin crear uno nuevo tal que todos los ceros queden al principio, los unos enmedio y los 2 al final
Solucion # @param {Integer[]} nums # @return {Void} Do not return anything, modify nums in-place instead. def sort_colors(nums) l = nums.length - 1 f = 0 i = 0 while i&amp;lt;= l if nums[i]==2 nums[l], nums[i] = nums[i], nums[l] l-=1 elsif nums[i]==0 nums[f], nums[i] = nums[i], nums[f] f+=1 i+=1 else i+=1 end end end Este programa funciona con tres apuntadores, uno que iterara por todo el array, uno para indicar el principio de el array, el cual avanzara cada que se el primero encuentre un cero, pues intercambiaran lugares y significara que desde 0 hasta su poscicion -1 todos los valores son 0, y el ultimo, el cual cumple la misma funcion que el segundo pero de manera inversa, para el final de el array.</description></item><item><title>Evaluar Notacion Polaca Inversa</title><link>https://senchpimy.github.io/problemas/evaluarnotacionpolaca/</link><pubDate>Sun, 14 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/evaluarnotacionpolaca/</guid><description>Evaluar Notacion Polaca Inversa Este problema consisten en dada una lista de numeros y simbolos evaluar esta lista como si fuiera una notacion polaca
Solucion # @param {String[]} tokens # @return {Integer} def eval_rpn(tokens) stack = [] while !tokens.empty? c = tokens.shift begin val = Integer(c) stack&amp;lt;&amp;lt;val rescue n1,n2 = stack.pop(2) case c when &amp;#34;+&amp;#34; res = n1+n2 when &amp;#34;-&amp;#34; res = n1-n2 when &amp;#34;*&amp;#34; res = n1*n2 when &amp;#34;/&amp;#34; res = (n1/n2.</description></item><item><title>atoi</title><link>https://senchpimy.github.io/problemas/atoi/</link><pubDate>Sat, 13 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/atoi/</guid><description>String a Entero Este problema consisten en convertir un string en un entero
Solucion # @param {String} s # @return {Integer} def my_atoi(s) mul = 1 sym = false val = 0 s.each_char do |c| next if c == &amp;#34; &amp;#34; &amp;amp;&amp;amp; !sym break if c == &amp;#34; &amp;#34; if ( c == &amp;#34;-&amp;#34; || c ==&amp;#34;+&amp;#34; ) &amp;amp;&amp;amp; !sym mul = -1 if c == &amp;#34;-&amp;#34; sym = true next end code = c.</description></item><item><title>Contar Agua De LLuvia</title><link>https://senchpimy.github.io/problemas/contaraguadelluvia/</link><pubDate>Thu, 11 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/contaraguadelluvia/</guid><description>Contar Agua de LLuvia Este problema consisten en dado una lista con numeros los cuales representan la altura de pilares en un contenedor, encontrar el volumen total de agua que se encuentra &amp;ldquo;atrapada&amp;rdquo; en el array
Solucion Mi primera solucion fue la siguiente
def min (a,b) a&amp;lt;b ? a : b end # @param {Integer[]} h # @return {Integer} def trap(h) left = 0 tot = h.length() - 1 vol_tot = 0 while left &amp;lt; tot min = h[left] right = left+1 while right&amp;lt;=tot break if h[right]&amp;gt;=min if right == tot left +=1 right = left end right+=1 end v = (right-left) * min(h[left],h[right]) less = h[left+1.</description></item><item><title>Buscar en Matriz 2D</title><link>https://senchpimy.github.io/problemas/buscarmatriz2d/</link><pubDate>Thu, 04 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/buscarmatriz2d/</guid><description>Buscar en Matriz 2d Este problema consisten en regresar un booleano dependiendo si un elemento se encuentra en una matriz de m*n en la cual esta ordenada de forma creciente
Solucion # @param {Integer[][]} matrix # @param {Integer} target # @return {Boolean} def search_matrix(matrix, target) m = matrix.length n = matrix[0].length l = 0 r = (m*n)-1 while l&amp;lt;=r mid = (l+r)/2 f = mid /n c= mid%n if matrix[f][c]==target return true elsif matrix[f][c]&amp;gt;target r=mid-1 else l = mid+1 end end false end Este programa considera la matriz como un solo array y para acceder a los indices adecuados este divide los valores por n pues asi tendriamos la columna y fila siendo el residuo y el resultado respectivamente</description></item><item><title>Suma De Tres</title><link>https://senchpimy.github.io/problemas/sumadetres/</link><pubDate>Tue, 02 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/sumadetres/</guid><description>Suma de Tres Este problema consiste en encontrar cada posible combinacion de 3 numeros sin prepetirse tal que la suma de estos 3 numeros sea igual a 0
Solucion # @param {Integer[]} nums # @return {Integer[][]} def three_sum(nums) nums = nums.sort len = nums.length-1 prev = nil result = [] for i in 0..len do next if i&amp;gt;0 &amp;amp;&amp;amp; nums[i-1] == nums[i] to_search = -nums[i] left=i+1 rigth = len while left &amp;lt; rigth current = nums[left]+nums[rigth] if current == to_search result &amp;lt;&amp;lt; [nums[i], nums[left], nums[rigth]] left+=1 while nums[left]==nums[left-1] and left&amp;lt;rigth left+=1 end elsif current &amp;gt; to_search rigth-=1 else left+=1 end end end result end Este programa primero ordena la lista, luego usa el algoritmo que se usa en sumaDos para buscar dos numeros que sumados den un numero objetivo, en este caso el opuesto de el numero que se esta buscando actualmente.</description></item><item><title>Escalera</title><link>https://senchpimy.github.io/problemas/escalera/</link><pubDate>Mon, 01 Jul 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/escalera/</guid><description>Escalera Este problema consisten en regresar un entero que indique todas las formas posibles en las cuales se puede subir una escalera de n escalones si en cada paso se puede escoger subir 1 o 2 escalones
Solucion # @param {Integer} n # @return {Integer} def climb_stairs(n) if n &amp;lt;= 3 return n end total = 0 restantes = n - 3 prev2 = 2 prev1 = 3 1.upto(restantes).each do total = prev1+prev2 prev2 = prev1 prev1 = total end total end Este programa toma en consideracion que para n siendo menor o igual a 3, el resultado sera igual que n, luego considera que la ecuacion para resolver este problema es la siguiente:</description></item><item><title>Mismo Arbol</title><link>https://senchpimy.github.io/problemas/mismoarbol/</link><pubDate>Sun, 30 Jun 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/mismoarbol/</guid><description>Arbol Este problema consisten en regresar un booleano que describe si dos raices de unos arboles describen dps arboles iguales
Solucion def is_same_tree(p, q) izq = [p] der = [q] while izq.length != 0 &amp;amp;&amp;amp; der.length != 0 e_izq = izq.pop e_der = der.pop if e_izq.nil? ^ e_der.nil? return false end next if e_izq == nil if e_izq.val != e_der.val return false end izq&amp;lt;&amp;lt;e_izq.left der&amp;lt;&amp;lt;e_der.left izq&amp;lt;&amp;lt;e_izq.right der&amp;lt;&amp;lt;e_der.right end true end Este programa lo resolvi creado dos ques para cada arbol, y añadiendo los nodos hoja de cada nodo a su respectiva lista y regresando false en la diferencia de valor de el nodo o de la arquitectura.</description></item><item><title>Entero A Romano</title><link>https://senchpimy.github.io/problemas/enteroaromano/</link><pubDate>Mon, 24 Jun 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/enteroaromano/</guid><description>Entero A romano Este problema consisten en dado un numero regresar un string que sea su representacion en numero romano de dicho numero
Solucion # @param {Integer} num # @return {String} def int_to_roman(num) u = {0=&amp;gt;&amp;#34;&amp;#34;, 1=&amp;gt;&amp;#34;I&amp;#34;, 2=&amp;gt;&amp;#34;II&amp;#34;, 3=&amp;gt;&amp;#34;III&amp;#34;, 4=&amp;gt;&amp;#34;IV&amp;#34;, 5=&amp;gt;&amp;#34;V&amp;#34;, 6=&amp;gt;&amp;#34;VI&amp;#34;, 7=&amp;gt;&amp;#34;VII&amp;#34;, 8=&amp;gt;&amp;#34;VIII&amp;#34;, 9=&amp;gt;&amp;#34;IX&amp;#34;} d = {0=&amp;gt;&amp;#34;&amp;#34;, 1=&amp;gt;&amp;#34;X&amp;#34;, 2=&amp;gt;&amp;#34;XX&amp;#34;, 3=&amp;gt;&amp;#34;XXX&amp;#34;, 4=&amp;gt;&amp;#34;XL&amp;#34;, 5=&amp;gt;&amp;#34;L&amp;#34;, 6=&amp;gt;&amp;#34;LX&amp;#34;, 7=&amp;gt;&amp;#34;LXX&amp;#34;, 8=&amp;gt;&amp;#34;LXXX&amp;#34;, 9=&amp;gt;&amp;#34;XC&amp;#34;} c = {0=&amp;gt;&amp;#34;&amp;#34;, 1=&amp;gt;&amp;#34;C&amp;#34;, 2=&amp;gt;&amp;#34;CC&amp;#34;, 3=&amp;gt;&amp;#34;CCC&amp;#34;, 4=&amp;gt;&amp;#34;CD&amp;#34;, 5=&amp;gt;&amp;#34;D&amp;#34;, 6=&amp;gt;&amp;#34;DC&amp;#34;, 7=&amp;gt;&amp;#34;DCC&amp;#34;, 8=&amp;gt;&amp;#34;DCCC&amp;#34;, 9=&amp;gt;&amp;#34;CM&amp;#34;} m = {0=&amp;gt;&amp;#34;&amp;#34;, 1=&amp;gt;&amp;#34;M&amp;#34;, 2=&amp;gt;&amp;#34;MM&amp;#34;, 3=&amp;gt;&amp;#34;MMM&amp;#34;} mm = num /1000 cc = (num%1000) /100 dd = (num%100) /10 uu = (num%10) /1 return m[mm]+c[cc]+d[dd]+u[uu] end Los limites dados son que ningun numero superara los 3999.</description></item><item><title>Contenedor Con más Agua</title><link>https://senchpimy.github.io/problemas/contenedorconmasagua/</link><pubDate>Sun, 23 Jun 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/contenedorconmasagua/</guid><description>Contenedor con más agua Este problema consisten en dado una lista con numeros los cuales representan la altura de pilares en un contenedor, encontrar cual es el volumen mayor que se encontrara entre dos pilares cualquiera
Solucion def min (a,b) a&amp;lt;b ? a : b end # @param {Integer[]} height # @return {Integer} def max_area(height) izq = 0 der = height.length - 1 m = 0 while izq &amp;lt; der v = (der-izq) * min(height[izq],height[der]) m = v if v&amp;gt;m if height[izq]&amp;lt; height[der] izq+=1 else der-=1 end end m end Este programa se resuelve iterando por todo el array, obtenemos el volumen con la formula de la distancia entre los dos puntos y la menor altura entre dos los multiplicamos y asi obtenemos el volumen y lo guardamos solo si es mayor que el anterior, y avanzamos los apuntadores hacia cualquiera que fuese el siguiente intento que existe una probabilidad de darnos un resultado mayor</description></item><item><title>Search Index</title><link>https://senchpimy.github.io/problemas/search_index/</link><pubDate>Fri, 21 Jun 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/search_index/</guid><description>Search Index Este problema consisten en implementar busqueda binaria
Solucion # @param {Integer[]} nums # @param {Integer} target # @return {Integer} def search_insert(nums, target) izq = 0 der = nums.length while izq &amp;lt;= der mid = (izq+der)/2 if nums[mid]==nil || mid == nil break end if nums[mid]&amp;lt;target izq+=1 elsif nums[mid]&amp;gt;target der -=1 else return mid end end izq end Solo que por algun motivo tenia que verificar que los dos valores no fueran nulos aunque cuando imprimia los valores en ningun momento estos eran nulos, y el input nunca era nulo, pero si quitaba esas 3 lineas el programa no funcionaba.</description></item><item><title>Sudoku</title><link>https://senchpimy.github.io/problemas/sudokuvalido/</link><pubDate>Fri, 21 Jun 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/sudokuvalido/</guid><description>Anagrama Este problema consisten en dado un sudoku regresar si el sudoku es valido, es decir no existe ningun numero repetido en las columnas, filas y cuadrados de 3x3
Solucion # @param {Character[][]} board # @return {Boolean} def is_valid_sudoku(board) cols=Hash.new{|h,k| h[k]= []} rows=Hash.new{|h,k| h[k]= []} sqr=Hash.new{|h,k| h[k]= []} board.each_with_index do |row,i| row.each_with_index do |col,j| next if col==&amp;#39;.&amp;#39; if cols[j].include?(col) || rows[i].include?(col) || sqr[[i/3,j/3]].include?(col) return false end cols[j]&amp;lt;&amp;lt;col rows[i]&amp;lt;&amp;lt;col sqr[[i/3,j/3]]&amp;lt;&amp;lt;col end end true end Este programa los resolvi teniendo un hashmap para cada fila, columna y cuadro de 3x3, y preguntando si el elemento que se esta procesando actualmente se encuentra dentro de los valores de el hashmap que se esta evaluando.</description></item><item><title>Add Two NUmbers</title><link>https://senchpimy.github.io/problemas/addtwonumbers/</link><pubDate>Thu, 20 Jun 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/addtwonumbers/</guid><description>Add Two Numbers Este problema consisten en dadas dos listas ligadas las cuales tienen los digitos de un numero entero en reversa y el problema consiste en sumar estos dos valores y regresar otra lista ligada en reversa con los digitos de el resultado
Solucion # Definition for singly-linked list. # class ListNode # attr_accessor :val, :next # def initialize(val = 0, _next = nil) # @val = val # @next = _next # end # end # @param {ListNode} l1 # @param {ListNode} l2 # @return {ListNode} def get_num(node) num = 0 mul = 1 while node !</description></item><item><title>Más uno</title><link>https://senchpimy.github.io/problemas/masuno/</link><pubDate>Wed, 19 Jun 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/masuno/</guid><description>Más uno El problema consiste que dado una lista que consiste en enteros y se supone que esta lista representa un entero en total, y el problema consiste en sumarle uno a este gran numero
Solucion Vamos a iterar la lista de forma inversa y le vamos a sumar 1 a el primer valor que sea diferente a 9 y regresamos la lista, en caso de que sea 9 lo convertimos en 0 y seguimos buscando uno que sea diferente a 9</description></item><item><title>Anagrama</title><link>https://senchpimy.github.io/problemas/agrupar_anagramas/</link><pubDate>Mon, 17 Jun 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/agrupar_anagramas/</guid><description>Anagrama Este problema consisten en dado una lista de palabras regresar una lista de listas de palabras que sean anagramas entre si
Solucion Este problema se soluciona primero iterando por cada palabra de el array y ordenandola, luego esta se añade en un hashmap donde la llave es la palabra ordenada y el valor es un array que contiene esta palabra, array que se expandira si al ordenar otra palabra de la lista original esta coincide con la llave.</description></item><item><title>Indice de la primera Ocurrencia</title><link>https://senchpimy.github.io/problemas/indiceprimeraocurrencia/</link><pubDate>Mon, 10 Jun 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/indiceprimeraocurrencia/</guid><description>Indice de la Primera Ocurrencia Este problema consisten en dados dos strings regresar el indice de la primera ocurrencia de un string dentro de otro
Solucion # @param {String} haystack # @param {String} needle # @return {Integer} def str_str(haystack, needle) if needle==&amp;#34;&amp;#34; return 0 end limit = haystack.length + 1 - needle.length (0..limit).each do |i| (0..needle.length).each do |j| if haystack[i+j] != needle[j] break end if j == (needle.length - 1) return i end end end return -1 end Este programa primero calcula hasta dode seria posible encontrar el string encontrar por su longitud dentro de el string en cual buscar, luego lo recorre e intenta comparar cada uno de los caracteres, si se han logrado comparar todos los caracteres de el segundo string entonces se ha encontrado el segundo string y se regresa el indice</description></item><item><title>Prefijo más largo</title><link>https://senchpimy.github.io/problemas/prefijolargo/</link><pubDate>Sat, 08 Jun 2024 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/prefijolargo/</guid><description>Prefijo Este problema consisten en dado un array de strings regresar el prefijo (los primeros caracteres) como string más largo que todos los strings de el array tengan en comun
Solucion # @param {String[]} strs # @return {String} def longest_common_prefix(strs) array = strs.shift prefix = &amp;#34;&amp;#34; array.split(&amp;#34;&amp;#34;).each_with_index do |char,index| strs.each do |str| if char != str[index] return prefix end end prefix += char end return prefix end Este programa toma el primer de el array, luego por cada elemento restante de el array va a comparar sus caracteres iniciales, y cuando detecta que son diferentes entonces significa que se encontro el largo maximo de el prefijo y se regresa el prefijo</description></item><item><title>Valor Maximo Despues De Separar</title><link>https://senchpimy.github.io/problemas/valormaximodespuesdeseparar/</link><pubDate>Fri, 22 Dec 2023 07:13:23 -0600</pubDate><guid>https://senchpimy.github.io/problemas/valormaximodespuesdeseparar/</guid><description>Valor Maximo Despues De Separar Este problema consiste en que dado un string de unos y ceros encontremos el valor maximo que se puede obtener despues de separa el string en 2 y sumar la cantidad de 0&amp;rsquo;s de un lado con la cantidad de 1&amp;rsquo;s de el otro.
Solucion # @param {String} s # @return {Integer} def max_score(s) s = s.split(&amp;#34;&amp;#34;) izq = 0 der = 0 s.each{|c| if c == &amp;#34;1&amp;#34; der=der+1 end } max = der-1 s.</description></item><item><title>Mayor Impar</title><link>https://senchpimy.github.io/problemas/mayorimpar/</link><pubDate>Fri, 15 Dec 2023 15:10:29 -0600</pubDate><guid>https://senchpimy.github.io/problemas/mayorimpar/</guid><description>Largest Odd Number In String Este problema consiste en encontrar el numero mayor impar en una cadena de texto
Solucion impl Solution { pub fn largest_odd_number(r: String) -&amp;gt; String { let mut len = r.len(); for c in r.chars().rev() { let val = c as u32 - 48; if val % 2 != 0 { return r[0..len].to_string(); } len -= 1; } String::new() } } La solucion consiste en que si encontramos el primer numero impar de el final hacia delante, entonces el mayor numero impar es la combinacion de ese junto todos los que estan al comienzo</description></item><item><title>Min Stack</title><link>https://senchpimy.github.io/problemas/minstack/</link><pubDate>Thu, 07 Dec 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/minstack/</guid><description>Min Stack Este problema consisten en tener un stack el cual siqmpre se le pueda requerir el menor elemento en el stack y este siempre lo puede regresar
Solucion Esta fue mi por algun motivo parece que leetcode no puede aceptar resultado que usen mallor y realloc, pues en mi computadora si funciono hasta cierto punto este primer intento
#include &amp;lt;iostream&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;malloc.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;limits.h&amp;gt; class MinStack { public: int min; int len; int *stack; int act; int com; MinStack() { stack =(int *) malloc (5*sizeof(int)); len = 5; act=0; min = INT_MAX; } void push(int val) { if (val&amp;lt;min) min=val; if (act+1==len){ realloc(stack, (len*2)*sizeof(int)); len = len*2; } //Añadir stack[act]=val; act++; } void pop() { com++; } int top() { return stack[com]; } int getMin() { return min; } void print(){ for (int i = 0; i&amp;lt;len;i++){ std::cout&amp;lt;&amp;lt;stack[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; } std::cout&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; } }; int main (int argc, char *argv[]) { MinStack* obj = new MinStack(); obj-&amp;gt;push(-2); obj-&amp;gt;push(0); obj-&amp;gt;push(-3); obj-&amp;gt;print(); std::cout&amp;lt;&amp;lt;obj-&amp;gt;getMin()&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; // return -3 obj-&amp;gt;pop(); std::cout&amp;lt;&amp;lt;obj-&amp;gt;top()&amp;lt;&amp;lt;&amp;#34;\n&amp;#34;; // return 0 std::cout&amp;lt;&amp;lt;obj-&amp;gt;getMin()&amp;lt;&amp;lt;&amp;#34; ?</description></item><item><title>Parentesis Valido</title><link>https://senchpimy.github.io/problemas/parentesisvalido/</link><pubDate>Tue, 05 Dec 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/parentesisvalido/</guid><description>Parentesis Valido Este problema consisten en regresar cierto si un string contiene una serire de parentesis que sean validos
Solucion def isValid(s: str) -&amp;gt; bool: fifo = [] for char in s: if char in &amp;#39;({[&amp;#39;: fifo.append(char) else: if not fifo: return False curr= fifo.pop() if (char == &amp;#39;)&amp;#39; and curr!= &amp;#39;(&amp;#39;) or (char == &amp;#39;}&amp;#39; and curr!= &amp;#39;{&amp;#39;) or (char == &amp;#39;]&amp;#39; and curr!= &amp;#39;[&amp;#39;): return False return not fifo Esta funcion primero añade a una lista los parentesis que abren y conforme la lista avanza el orden en en el que salen debe ser el mismo con el que entran por lo que si esto no es asi entonces el parentesis no es valido y si al final la lista esta vacia se regresa True</description></item><item><title>Sqrt</title><link>https://senchpimy.github.io/problemas/sqrt/</link><pubDate>Tue, 05 Dec 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/sqrt/</guid><description>Sqrt Este problema consisten en encontrar el numero entero más cercano a la raiz de un numero dado.
Solucion El problema consiste en una busqueda binaria en el rango desde 0 hasta el numero dado
func mySqrt(x int) int { st := 0 max := x res := 0 for st &amp;lt;= max { m := st + ((max - st) / 2) fmt.Println(m) sq := m * m if sq &amp;gt; x { max = m - 1 } else if sq &amp;lt; x { st = m + 1 res = m } else { return m } } return res }</description></item><item><title>Romano A Entero</title><link>https://senchpimy.github.io/problemas/romanotaentero/</link><pubDate>Thu, 30 Nov 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/romanotaentero/</guid><description>Romano A Entero Este problema consisten en regresar el valor entero de un numero dad su representacion como numero romano
Solucion func romanToInt(s string) int { total := 0 s += &amp;#34; &amp;#34; m := make(map[byte]int) m[&amp;#39;I&amp;#39;] = 1 m[&amp;#39;V&amp;#39;] = 5 m[&amp;#39;X&amp;#39;] = 10 m[&amp;#39;L&amp;#39;] = 50 m[&amp;#39;C&amp;#39;] = 100 m[&amp;#39;D&amp;#39;] = 500 m[&amp;#39;M&amp;#39;] = 1000 for i := 0; i &amp;lt; len(s)-1; i++ { char := s[i] n_char := s[i+1] if m[n_char] &amp;gt; m[char] { total += (m[n_char] - m[char]) i++ continue } total += m[char] } return total } Este problema se resuelve primero mapeando cada posible caracter a su respectivo valor, luego se itera por todo el array y solo se busca la posible condicion de que el numero este restando y para cubrir esta condicion hay que preguntar si el siguiente caracter es mayor.</description></item><item><title>Combinar Array Ordenado</title><link>https://senchpimy.github.io/problemas/combinararrayordenado/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/combinararrayordenado/</guid><description>Conbinar Array Ordenado Este problema consisten en combinar dos arrays que estan ordenados
Solucion Primero intente esto pues pense que podria funcionar:
# @param {Integer[]} nums1 # @param {Integer} m # @param {Integer[]} nums2 # @param {Integer} n # @return {Void} Do not return anything, modify nums1 in-place instead. def merge(nums1, m, nums2, n) return if n == 0 sec_i = 0 tmp = nil 0.upto(m) do |i| break if sec_i==n end if nums1[i]&amp;gt;nums2[sec_i] tmp = nums1[i] nums1[i]=nums2[sec_i] nums2[sec_i]=tmp sec_i+=1 else next end end nums2 = nums2.</description></item><item><title>Decima Linea</title><link>https://senchpimy.github.io/problemas/decima_linea/</link><pubDate>Fri, 30 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/decima_linea/</guid><description>Decima Linea Este problema consisten en imprimir la demcima linea de un archivo usando comando de shell, mi primera solucion fue la siguiente:
Solucion head file.txt --line 10 | tail --line 1 Pero fallaba cuando el documento no tenia mas de 10 lineas, entonces con awk tienen la varibale NR que practicamente un contador de lineas,etonces se puede usar de la siguiente manera
awk &amp;#39;NR == 10&amp;#39; file.txt Pero esta solucion tardaba mucho entonces con sed tambien se puede con</description></item><item><title>Numero Valido</title><link>https://senchpimy.github.io/problemas/numero_valido/</link><pubDate>Thu, 29 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/numero_valido/</guid><description>Numero Valido Este problema consisten en regresar todos los numeros en un texto que cumpla con una serie de caracteristicas que lo verifican como un numero de telefono valido, ejemplos podiran ser los siguientes
987-123-4567
(123) 456-7890
Solucion grep -e &amp;#34;^[0-9]\{3\}\-[0-9]\{3\}\-[0-9]\{4\}$&amp;#34; -e &amp;#34;^([0-9]\{3\}) [0-9]\{3\}\-[0-9]\{4\}$&amp;#34; file.txt En este vez usamos expresiones regulares para poder buscar las ocurrencias, con grep buscamos estas equivalencias, con los simbolos ^ y $ decimos que seleccionamos todos los caracteres en una linea, con el texto [0-9] decimos que el caracter en esa poscicion puede ser un valor desde el 0 hasta el 9 y con {3} hace que encuentre 3 caracteres de concuerden con el caracter anterior, y como el caracter anterior es un numero entre 0 y 9, luego repetimos este patron y agregamos los caracteres - y () para que concuerden con los numeros validos</description></item><item><title>Comprar Y Vender</title><link>https://senchpimy.github.io/problemas/compraryvender/</link><pubDate>Mon, 19 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/compraryvender/</guid><description>Mejor Momento para comprar y vender Este problema consiste en regresar el encontrar la diferencia maxima entre un minimo y un maximo despues del nminimo.
Yo primero lo intente por fureza bruta, intentando cada posibilidad hasta obtener el mayor haciendo de mi solucion O(N^2), haciendolo bastante lento
Solucion def solucion(self, nums): max=0 for i in range(len(nums)): for j in nums[i:]: if j-nums[i]&amp;gt;max: max=j-nums[i] return max</description></item><item><title>Busqueda Binaria</title><link>https://senchpimy.github.io/problemas/busquedabinaria/</link><pubDate>Sat, 17 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/busquedabinaria/</guid><description>Busqueda Binaria Este problema consiste en implementar la busqueda binaria
Solucion # @param {Integer[]} nums # @param {Integer} target # @return {Integer} def search(nums, target) izq = 0 der = nums.length-1 until izq &amp;gt; der mid = izq + (der - izq) / 2 if nums[mid]==target return mid elsif nums[mid]&amp;lt;target izq=mid +1 else nums[mid]&amp;gt;target der =mid -1 end end -1 end</description></item><item><title>Producto De Un Array</title><link>https://senchpimy.github.io/problemas/producto_array/</link><pubDate>Fri, 16 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/producto_array/</guid><description>Producto de lista excepto mismo Este problema consisten hacer un vector el cual cada elemento debe ser el resultado de la multiplicacion de todos los elementos de un vector excepto el del indice el cual va a ocupar
Primero se me ocurrio hacer la multiplicacion de todos los elementos por cada iteracion y saltar cuando ocurra el indice, despues asignar el elemento al indice indicado, pero esto es bastante lento pues tendria una complejidad de tiempo cuadrada y se repiten muchisimas operaciones</description></item><item><title>Invertir Lista</title><link>https://senchpimy.github.io/problemas/invertirlista/</link><pubDate>Wed, 14 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/invertirlista/</guid><description>Invertir lista ligada Este problema consisten en invertir una lista ligada
Solucion class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* final = head; ListNode* inicio = NULL; while (final) { ListNode* sig = final-&amp;gt;next; final-&amp;gt;next = inicio; inicio = final; final = sig; } return inicio; } }; En este problema creamos un nodo que apunte al ultimo nodo agregado, este se va a llamar final y otro que sea el nodo al cual final esta apuntando, mientras que el final no sea un valor nulo, creamos un nuevo nodo que sea el que sigue en la lista en su orden original, este se llama inicio pues sera el inicio de la nueva lista, entonces al final lo apuntamos al incio, y luego volvemos al inicio el primer nodo en la nueva lista y final sigue siendo el ultimo nodo en la lista original.</description></item><item><title>Suma De Dos</title><link>https://senchpimy.github.io/problemas/sumadedos/</link><pubDate>Wed, 14 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/sumadedos/</guid><description>Suma de Dos Este problema consiste en encontrar la ubicacion de dos numeros en un vectos ordenado de forma ascendente que sumados den como resultado un valor deseado.
Solucion class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; arr, int l, int r, int x) { while (l &amp;lt;= r) { int m = l + (r - l) / 2; if (arr[m] == x) return m; if (arr[m] &amp;lt; x) l = m + 1; else r = m - 1; } return -1; } vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; numbers, int target) { int lon = numbers.</description></item><item><title>palindrome</title><link>https://senchpimy.github.io/problemas/palindrome/</link><pubDate>Mon, 12 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/palindrome/</guid><description>Palindrome Este problema consisten en verificar si un string es un palindrome
Solucion class Solution { public: bool isPalindrome(string s) { s.erase(std::remove_if(s.begin(), s.end(), []( auto const&amp;amp; c ) -&amp;gt; bool { return !std::isalnum(c); } ), s.end()); int j = s.length()-1; for (int i =0; i&amp;amp;lts.length()/2;i++){ if (tolower(s[j])!=tolower(s[i])){ return false; } j--; } return true; } }; En la primera linea primero eliminamos todos los caracteres que no sean alfanumericos, la funcion .</description></item><item><title>Top K Elementos</title><link>https://senchpimy.github.io/problemas/topkelementos/</link><pubDate>Mon, 12 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/topkelementos/</guid><description>Top K Elementos Este problema consisten contar cuantas veces aparece un elemento en un vector y regresar una lista con K elementos, los cuales sean los de mayor repeticion en el primer vector, este fue mi primer intento:
Primer Intento #include &amp;lt;map&amp;gt; class Solution { public: void insertar(int num,int k,int* vals){ for (int i=0; i&amp;lt;k;i++){ if (num&amp;lt;vals[i]){ i=i-1; for (int j=0;j&amp;lt;i;j++) vals[j]=vals[j+1]; vals[i]=num; break; } } } vector&amp;lt;int&amp;gt; topKFrequent(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { map&amp;lt;int,int&amp;gt; mapa; for (int element : nums) { mapa[element]++; } int vals[k]; int l=0; for (auto i: mapa){ if (l==k) break; vals[l]=i.</description></item><item><title>linearecta</title><link>https://senchpimy.github.io/problemas/linearecta/</link><pubDate>Sun, 11 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/linearecta/</guid><description>Check Straight Line Este problema consisten en verificar si un arreglo de coordenadas son una linea recta.
Solucion def checkStraightLine(self,coordinates): (x0,y0)=coordinates[0] (x1,y1)=coordinates[1] for x,y in coordinates[2:]: if (x1-x0)*(y-y1)!=(x-x1)*(y1-y0) return False return True Primero definimos que una linea recta son dos puntos en donde la pendiente es igual La logica de este codigo consiste en obtener evaluar la pendiente de los siguientes puntos con respecto a la de los dos primeros. Por lo que necesitamos iterar entre toda la lista, menos entre los dos primeros puntos pues si la lista solo tiene dos puntos estos formaran ya una linea recta</description></item><item><title>Anagrama</title><link>https://senchpimy.github.io/problemas/anagrama/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/anagrama/</guid><description>Anagrama Este problema consisten en regresar cierto si un string es un anagrama del otro
Solucion #include class Solution { public: bool isAnagram(string s, string t) { map&amp;lt;tchar, int&amp;gt; mapa; map&amp;lt;tchar, int&amp;gt; mapa2; if (s.length()!=t.length()) return false; for (int i = 0; i&amp;lt;s.length();i++){ mapa[s[i]]++; mapa2[t[i]]++; } for (int i = 0; i&amp;lt;s.length();i++){ if (mapa[s[i]]!=mapa2[s[i]]) return false; } return true; } }; Este programa los resolvi mapeando todos los elementos de ambos strings y si la cantidad de ambos elementos son iguales entonces se puede decir que estos son anagramas</description></item><item><title>Anagrama</title><link>https://senchpimy.github.io/problemas/temperaturasdiarias/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/temperaturasdiarias/</guid><description>Anagrama Este problema consisten en dado un array en donde cada elemento representa la temperatura en un dia, regresar otro array que contenga cuantos dias faltan para que se tenga una temperatura mayor
Solucion My primera solucion O(n^2) fue la siguiente
# @param {Integer[]} temperatures # @return {Integer[]} def daily_temperatures(temp) tot = [] len = temp.length-1 temp.each_with_index do |val,index| n = 0 l = nil index.upto(len) do |i| break if temp[i]&amp;gt;val n+=1 l = i end n = 0 if l == len tot&amp;lt;&amp;lt;n end tot end Pero era muy tardada, entonces la solucion es la siguiente</description></item><item><title>duplicado</title><link>https://senchpimy.github.io/problemas/duplicado/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/duplicado/</guid><description>Contains Duplicate Este problema consisten en regresar cierto si hay dos valores iguales un arreglo
Solucion class Solution(object): def containsDuplicate(self, nums): &amp;#34;&amp;#34;&amp;#34; :type nums: List[int] :rtype: bool &amp;#34;&amp;#34;&amp;#34; nums.sort() for i in range(len(nums)-1): if nums[i]==nums[i+1]:return True return False Este programa consiste en primero ordenar la lista, luego verificar si alguno de los elementos en la lista es igual al que le sigue.
Este programa vencio al 93% de las otras posibles respuestas en cuanto al consumo de memoria, pues no estamos en ninguno momento estamos alojando memoria para alguna variable, pues solamente estamos consultando los valores ya alojados, pero quedo atras ante el 95% de las respuestas en cuanto al tiempo de ejecucion, pues se tiene que ordenar todo el array primero.</description></item><item><title>Invertir Numero</title><link>https://senchpimy.github.io/problemas/reverse_int/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/reverse_int/</guid><description>Anagrama Este problema consiste en tomar un numero de 32 bits y luego invertirlo
Solucion La siguiente fue mi primera solucion
# @param {Integer} x # @return {Integer} def reverse(x) positive = x&amp;gt;=0? 1:-1 x = x.abs max = 2147483647 max_rm = max%10 min = -max - 1 min_rm = min%10 num = 0 while x!=0 dig = x%10 x = x / 10 if (num &amp;gt; max/10 || (num==max/10 &amp;amp;&amp;amp; dig&amp;gt;=max_rm)) return 0 end if (num &amp;lt; min/10 || (num==min/10 &amp;amp;&amp;amp; dig&amp;lt;=min_rm)) return 0 end num*=10 num+=dig end num *= positive num end Este programa primero toma el valor absoluto de el numero y guarda si es positivo o negativo, esto por que en algunos lenguajes el modulo de los numeros negativos funciona de diferentes maneras.</description></item><item><title>fizzbuzz</title><link>https://senchpimy.github.io/problemas/fizzbuzz/</link><pubDate>Wed, 07 Jun 2023 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/fizzbuzz/</guid><description>FizzBuzz Este problema consisten en imprimir (en el caso de la pagina de leetcode devolver un array) el cual contenga los numeros de i hasta n, pero si un numero es divisible entre tres en lugar de un numero seria el valor Fizz, si es entre 5 seria Buzz y si es entre ambos seria FizzBuzz,
Solucion class Solution(object): def fizzBuzz(self, n): &amp;#34;&amp;#34;&amp;#34; :type n: int :rtype: List[str] &amp;#34;&amp;#34;&amp;#34; return [(&amp;#34;Fizz&amp;#34;\*(i%3==1)+&amp;#34;Buzz&amp;#34;\*(i%5==1)or str(i)) for i in range(1,n+1)] La logica de este codigo consiste en solo una linea que regresa una lista de strings, la parte (&amp;ldquo;Fizz&amp;rdquo;*(i%3==1)+&amp;ldquo;Buzz&amp;rdquo;*(i%5==1)or str(i)) esta entre parentesis y esta adelante del for pues esto hace que se agregue el valor entre parentesis la cantidad de veces que llama el for, el cual va desde 1 hasta n+1 pues la funcion range toma el primer argumento hasta el segundo menos uno, por eso se necesita agregar uno.</description></item><item><title>Combinar Dos Tablas</title><link>https://senchpimy.github.io/problemas/combinar_dos_tablas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/combinar_dos_tablas/</guid><description>Combinar dos tablas Este programa consiste en juntas dos tablas en base a un cambo en SQL
Solucion SELECT firstName, lastName, city, state FROM Person LEFT JOIN Address USING (personId) Escojemos los campos de firstName, lastName, city, state de la tabla Person con LEFT JOIN decimos que devuelva todos los registros de la tabla Address que no esten en Person, con USING significa que usara la columna personId para unir las dos tablas</description></item><item><title>Eliminar Duplicados</title><link>https://senchpimy.github.io/problemas/eliminar_duplicados/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/eliminar_duplicados/</guid><description>Eliminar Duplicados Este programa consiste en eliminar los elementos duplicados de un vector y regresar cuanto elementos unicos este tenia
Solucion class Solution { public: int removeDuplicates(vector&amp;amp;ltint&amp;gt;&amp;amp; nums) { int j = 1; int size = nums.size(); for(int i = 1; i &amp;lt; size; i++) if(nums[i] != nums[i - 1]){ nums[j] = nums[i]; j++; } return j; } }; Este programa itera por todo el vector y como este esta ordenado es cuando el numero anterior al numero de la iteracion actual son diferentes que se puede decir que es otro elemento del array, por lo que se aumenta el valor, al mismo tiempo como tenemos el indice de que elementos unicos lo podemos intercambiar para asi poder reducir su tamaño a solo elementos unicos</description></item><item><title>Tres Impares Seguidos</title><link>https://senchpimy.github.io/problemas/tresimparesseguidos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://senchpimy.github.io/problemas/tresimparesseguidos/</guid><description>Anagrama Este problema consisten en regresar cierto si dada una lista se encuentras tres impares seguidos
Solucion class Solution: def threeConsecutiveOdds(self, arr: List[int]) -&amp;gt; bool: l = len(arr) for i in range(l-2): if arr[i]%2!=0 and arr[i+1]%2!=0 and arr[i+2]%2!=0: return True return False Pero me di cuenta que se podria ser más rapido si se suman en lugar de hacer las comparaciones:
class Solution: def threeConsecutiveOdds(self, arr: List[int]) -&amp;gt; bool: l = len(arr) for i in range(l-2): if arr[i]%2 +arr[i+1]%2+ arr[i+2]%2==3: return True return False</description></item></channel></rss>